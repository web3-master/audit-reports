# JUSDBankStorage.sol#accrueRate function has an error in calculating the tRate.

## Summary
JUSDBankStorage.sol#accrueRate function calculates the value of tRate larger than the right value.
Thus the borrowers of JUSDBank will lose more JUSD tokens when repaying or liquidating.

## Vulnerability Detail
JUSDBankStorage.sol#accrueRate function and getTRate function are the following.
```solidity
    function accrueRate() public {
        uint256 currentTimestamp = block.timestamp;
        if (currentTimestamp == lastUpdateTimestamp) {
            return;
        }
        uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);
59:     tRate = tRate.decimalMul((timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR + 1e18);
        lastUpdateTimestamp = currentTimestamp;
    }

    function getTRate() public view returns (uint256) {
65:     uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);
        return tRate + (borrowFeeRate * timeDifference) / Types.SECONDS_PER_YEAR;
    }
```
As can be seen, the calculation formula for tRate in L59 of accrueRate function differs with L65 of getTRate function.
When tRate = 1e18, the formula of L59 is equal to L65.
JUSDBank.sol#L39 is following.
```solidity
        tRate = Types.ONE;
```
That is, since the initial value of tRate is 1e18 and it increases by time, tRate > 1e18 will be always hold true.
When tRate > 1e18, the value of L59 will be larger than L65 as follows.
```solidity
    tRateInL59 = tRate.decimalMul((timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR + 1e18)
          = tRate.decimalMul((timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR) + tRate.decmialMul(1e18)
          = tRate * (timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR / 1e18 + tRate * 1e18 / 1e18
          > (timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR + tRate = tRateInL65
```
Since tRate > 1e18 increases by time, the difference of two values will be larger and larger.
Since borrowRate is the increase amount of tRate in a year, the L65 of getTRate is right but not for L59 of accrueRate function.

## Impact
accrueRate function calculates the value of tRate larger than the right value.
accrueRate function is called from borrow, repay and liquidate function of JUSDBank.sol.
Thus borrowers will lose more JUSD tokens when repaying or liquidating.
As tRate > 1e18 continues to increases, the deviation of calculation becomes larger and larger.

## Code Snippet
https://github.com/sherlock-audit/2023-12-jojo-exchange-update/blob/main/smart-contract-EVM/src/JUSDBankStorage.sol#L59

## Tool used
Manual Review

## Recommendation
Modify JUSDBankStorage.sol#accrueRate function as follows.
```solidity
    function accrueRate() public {
        uint256 currentTimestamp = block.timestamp;
        if (currentTimestamp == lastUpdateTimestamp) {
            return;
        }
--      uint256 timeDifference = block.timestamp - uint256(lastUpdateTimestamp);
--      tRate = tRate.decimalMul((timeDifference * borrowFeeRate) / Types.SECONDS_PER_YEAR + 1e18);
++      tRate = getTRate();
        lastUpdateTimestamp = currentTimestamp;
    }
```